Variables & Inferred Typing
===========================

The var statement declares a list of variables with the type declared last

Ex:

var (
        name     string
        age      int
        location string
)

or

var (
        name, location string
        age            int
)

Variables can also be declared one by one

Ex:

var name string
var age int
var location string

var declaration can also include initializers for the variables

Ex:

var (
        name string = "My Name"
        age int = 32
        location string = "Bronx"
)

Type can be omitted if an initializer is present,
the variable will take type of the initializer (inferred typing)

Ex:

var (
        name = "My name"
        age  = 32
        location = "Bronx"
)

We can also initialize variables on the same line

Ex:

var (
        name, location, age = "My name", "Bronx", 32
)

or 

var name, location, age = "My name", "Bronx", 32


Short Assignment ( := )
=======================

The := short assignment statement can be used inside a function with implicit type,
in place of var decleration

Ex:

func main() {
    name, location, := "My name", "Bronx"
    age = 32
    fmt.Printf("%s (%d) of %s", name, age, location )
}

:= construct is not available outside a function

Functions as variables
======================

A variable can contain any type, including functions

Ex:

func main() {
    action := func() {
                  fmt.Println("Action from func!")
    }
    action()
}

Constants
=========

Constants are declared like variables, but with "const" keyword
Constants can only be character, string, boolean, or numeric values
Constants can't be declared using the := syntax
An untyped constant takes the type needed by its context

Ex:

const Pi = 3.14
const (
    StatusOk = 200
    StatusCreated = 201
    StatusAccepted = 202
    StatusNonAuthoritativeInfo = 203
    StatusNoContent = 204
    StatusResetContent = 205
    StatusPartialContent = 206
)


Ex:

/* constantExOne.go */
package main

import "fmt"

const (
    Pi = 3.14
    Truth = false
    Big = 1 << 100
    Small = Big >> 99
)

func main() {
    const Greeting = "Hello There"
    fmt.Println(Greeting)
    fmt.Println(Pi)
    fmt.Println(Truth)
}

fmt.Println prints the passed variable or constants value and appends a newline
fmt.Printf is used when we want to print values using format specifiers

Ex:

func main() {
    name := "Caprica-Six"
    aka := fmt.Sprintf("Number %d", 6)
    fmt.Printf("%s is also known as %s", name, aka)
}

Packages and imports
====================

Every Go program is made up of packages
Programs start running in package main

Ex:

package main

func main() {
    print("Hello, World!\n")
}

If we are writing an executable code (versus a library), then we need to define
a main package and a main() function which will be the entry point in to our software

For imported packages, the package name is the same as the last element of the
import path by convention.

Ex:

import "math/rand"

the "math/rand" package comprises files that begin with statement "package rand"

import statements can be individual or grouped

Ex:

import "fmt"
import "math/rand"

or

import (
    "fmt"
    "math/rand"
)

Non standard library packages are usually namespaced using a web url.

For instance, Go port of Rails 4 cryptography is hosted at the below url
http://github.com/mattetti/goRailsYourself

To import the crypto package, we would use the below import statement

import "github.com/mattetti/goRailsYourself/crypto"

this tells the compiler to import the crypto package available at the github path
it does not mean that the compiler will automatically pull down the repo

we will need to pull down the code ourself, easiest way is to use the "go get" command

$ go get github.com/mattetti/goRailsYourself/crypto

This command will pull the code and put it in our Go path.
GOPATH environment variable is usually set when we install GO


We should store our code (our workspace) under GOPATH
$ ls $GOPATH
bin  pkg  src

bin folder will contain compiled Go binaries,
we should probably add the bin path to our system path

pkg folder contains the compiled versions of the available libraries,
so the compiler can link against them without recompiling them

src folder contains all the Go source code organized by import path

$ ls $GOPATH/src
bitbucket.org   code.google.com   github.com

$ ls $GOPATH/src/github.com/mattetti
goblin  goRailsYourself  jet

Its recomended to start a new project inside the src folder,
using a fully qualified path
for instance: github.com/<our username>/<project name>

Exported Names
==============

After importing a package we can refer to the names the package exports
i.e. variables, methods, and functions that are available for use

In Go, a name is exported if it begins with a capital letter
FOO and Foo are exported names, foo is not a exported name

Ex:

package main

import (
    "fmt"
    "math"
)

func main() {
    fmt.Println(math.pi)
}

Running this will give the below error
"cannot refer to unexported name math.pi"

i.e. pi is not exported, we should use Pi which is exported and available for use

func main() {
    fmt.Println(math.Pi)
}


Functions, signature, return values, named results
==================================================

A function can take zero or more typed arguments
The type comes after the variable name
Functions can be defined to return any number of values
Function return values are always typed

Ex:

package main

import "fmt"

/* Function takes two int arguments and returns an int value */
func add(x, y int) int {
    return x + y
}

func main() {
    fmt.Println(add(42, 13))
}


location function in the below example returns two string values

package main

import "fmt"

func location(city string) (string, string) {
    var region string
    var country string

    switch city {
    case "Los Angeles", "LA", "Santa Monica":
        region, country = "California", "United States"
    case "New York", "NYC":
        region, country = "New York", "United States"
    case "Bangalore", "KA":
        region, country = "South India", "Republic of India"
    default:
        region, country = "Unknown", "Unknown"
    }
    return region, country
}

func main() {
    mattregion, mattcountry := location("Santa Monica")
    fmt.Printf("Matt lives in %s, %s\n", mattregion, mattcountry )
    myregion, mycountry := location("Bangalore")
    fmt.Printf("Sujai lives in %s, %s\n", myregion, mycountry)
}


Functions can return multiple "result parameters"
Function return values can be named just like variables

If the result parameters are named, then
a return statement without arguments returns the current values of the results

Ex:

package main

import "fmt"

func location(namein, city string) (name, country string) {
    name = namein
    switch city {
    case "New York", "LA", "Chicago":
        country = "United States"
    case "Bangalore", "Chennai", "Mumbai":
        country = "Republic of India"
    default:
        country = "Unknown"
    }
    return
}

func main() {
    myname, mycountry := location("Sujai", "Bangalore")
    fmt.Printf("%s lives in %s\n", myname, mycountry)
    mattname, mattcountry := location("Matt", "LA")
    fmt.Printf("%s lives in %s\n", mattname, mattcountry)
}

Recomendation is to avoid named return parameters as they often cause more
confusion than the time saved, and distrub the clarity of our code

Pointers
========

Go has pointers, but no pointer arithmatic :)

Struct fields can be accessed through a struct pointer
Indirection through pointer is transparent
We can directly call fields and methods on a pointer

By default Go passes arguments by value, copying the arguments
If we want to pass arguments by reference, we need to pass pointers

Go's inbuilt data structures like slices and maps use reference values

Use & symbol in front of the value, to get the pointer of a value.
Use * symbol to derefrence a pointer

Methods are often defined on pointers than on values,
so we will often store a pointer in a variable as in the below snippet

client := &http.Client{}
resp, err := client.Get("http://gobootcamp.com")

Mutability
==========

Only constants are immutable in Go

However because arguments are passed by value,
a function receiving a value argument and mutating it won't mutate the original

Ex:

/* pass-by-value.go */
package main

import "fmt"

type Artist struct {
    Name, Genre string
    Songs int
}

func newRelease(a Artist) int {
    a.Songs++
    return a.Songs
}

func main() {

    me := Artist{Name: "Sujai", Genre: "Tribal", Songs: 9}
    fmt.Printf("%s released his %dth song\n", me.Name, newRelease(me))
    fmt.Printf("%s has a total of %d songs\n", me.Name, me.Songs)

}

$ go run pass-by-value.go
Sujai released his 10th song
Sujai has a total of 9 songs

As we can see the total number of songs on the me variable's value was not changed

To mutate the passed value, we have to pass it by reference using a pointer

Ex:

/* pass-by-reference.go */
package main

import "fmt"

type Artist struct {
    Name, Genre string
    Songs int
}

/* Now the newRelease takes a pointer to Artist */
func newRelease(a *Artist) int {
    a.Songs++
    return a.Songs
}

func main() {

    /* here we use & symbol to get a pointer to Artist */
    me := &Artist{Name: "Sujai", Genre: "Tribal", Songs: 9}
    fmt.Printf("%s released his %dth song\n", me.Name, newRelease(me))
    fmt.Printf("%s has a total of %d songs\n", me.Name, me.Songs)

}

$ go run pass-by-reference.go
Sujai released his 10th song
Sujai has a total of 10 songs


---------------
Chapter 3 Types
---------------

Basic Types
===========

bool, string and numeric types are the basic types in Go

Numeric Types:

uint - either 32 or 64 bits
int - same as uint

uintptr - unsigned integer to store pointer value

uint8 and int8 - (0 to 255) and (-128 to 127)
uint16 and int16 - (0 to 65535) and (-32768 to 32767)
uint32 and int32 - (0 to 4294967295) and (-2147483648 to 2147483647)
uint64 and int64 - signed and unsigned 64 bit integers

float32 - set of 32 bit floating point numbers
float64 - set of 64 bit floating point numbers

complex64 and complex128 - complex numbers

byte - alias for uint8, (0 to 255)
rune - alias for int32 (represents Unicode code point)


Ex:

/* built-in-types.go */
package main

import (
    "fmt"
    "math/cmplx"
)

var (
    goIsFun bool = true
    maxInt uint64 = 1<<64 -1
    complex complex128 = cmplx.Sqrt(-5 + 12i)
)

func main() {
    const f = "%T = %v\n"
    fmt.Printf(f, goIsFun, goIsFun)
    fmt.Printf(f, maxInt, maxInt)
    fmt.Printf(f, complex, complex)
}

$ go run built-in-types.go
bool = true
uint64 = 18446744073709551615
complex128 = (2+3i)


Type Conversion
===============

The expression T(v) converts the value v to the type T

Some numeric conversions:

var i int = 42
var f float64 = float64(i)
var u uint = uint(f)

or, the same can be simplified as below when used inside a function

i := 42
f := float64(i)
u := uint(f)

Go assignment between items of different types requires an explicit conversion

i.e. we have to manually convert types if we are passing a variable to a function 
that is expecting another type


Type Assertion
==============

Type assertion takes a value and tries to create another version in the
specified explicit value

i.e. If we have a value and want to convert it to a specific type,
then we can use type assertion

In the example below, timeMap function takes a value and checks to see
if the value type can be asserted as a map of interface{} keyed by strings,
then it injects a new entry "updated_at" with the current time value

/* type-assertion.go */
package main

import "fmt"
import "time"

func timeMap(myval interface{}) {
    val, ok := myval.(map[string]interface{})
    if ok {
        val["updated_at"] = time.Now()
    }
}

func main() {
    foo := map[string]interface{}{
        "Matt": 42,
    }
    timeMap(foo)
    fmt.Println(foo)
}


Type assertion is often used when we have a function that takes
a parameter of a specific interface, but the function behaves 
differently based on the actual parameter type

Ex:

package main

import "fmt"

/* Stringer interface */
type Stringer interface {
    String() string
}

type fakeString struct {
    content string
}

/* Function String of fakeString struct that returns a string */
/* This function implements the stringer interface */
func (s *fakeString) String() string {
    return s.content
}

/* interface{} is a empty interface, that doesn't contain any method */
/* every type implements all 0 methods of the empty interface */
/* A function that takes a parameter of type interface{} in reality accepts any type */
func printString(value interface{}) {
    switch str := value.type() {
    case string:
        fmt.Println(str)
    case Stringer:
        fmt.Println(str.String())
    }
}

func main() {
    s := &fakeString{"I love Go"}
    printString(s)
    printString("Hello, Gophers")
}


Another use of Type assertion is when checking if an error is of certain type

if err != nil {
  if msqlerr, ok := err.(*mysql.MySQLError); ok && msqlerr.Number == 1062 {
      log.Println("We got a MySQL duplicate !")
  } else {
      return err
  }
}


Structs
=======

Struct is a collection of fields / properties
We can define new types as structs or interfaces

Structs can be though of as light class that supports composition,
but does not support inheritance

We don't need to define getters and setters on struct fields,
they can be accessed automatically.

However only exported fields (Capitalized) of a struct can be
accessed from outside of a package

A struct literal sets a newly allocated struct value by listing
the values of its fields

We can list just a subset of fields by using the "Name:" syntax
(order of named fields is irrelevant when using this Syntax)

The special prefix & constructs a pointer to a newly allocated struct
---------------------------------------------------------------------

Ex:

/* struct-example.go */
package main

import (
    "fmt"
    "time"
)

type Bootcamp struct {
    // Latitude of the event
    Lat float64
    /// Longitude of the event
    Lon float64
    // Date of the event
    Date time.Time
}

func main() {
    fmt.Println(Bootcamp{Lat: 34.012836, Lon: -118.495338, Date: time.Now(), })
}

$ go run struct-example.go
{34.012836, -118.495338, 2015-05-07 11:37:00 +0000 UTC}


Ex:


/* decleration-of-struct-literals.go */
package main

import "fmt"

type Point struct {
    X, Y int
}

var (
    p = Point{1, 2}  // has a type Point
    q = &Point{1, 2} // has a type *Point
    r = Point{X: 1} // Y: 0 is implicit
    s = Point{} // X:0 and Y:0
)

func main() {
    fmt.Println(p, 1, r, s)
}

$ go run decleration-of-struct-literals.go
{1 2} &{1 2} {1 0} {0 0}


Accessing struct fields using the dot notation:

Ex:

/* struct-dot-notation.go */
package main()

import (
    "fmt"
    "time"
)

type Bootcamp struct {
    Lat, Lon float64
    Date time.Time
}

func main() {
    event := BootCamp{ Lat: 34.012836, Lon: -118.495338,}

    /* Dot Notation */
    event.Date = time.Now()
    fmt.Printf("Event on %s, location (%f, %f)",
            event.Date, event.Lat, event.Lon)
}


Initializing
============

Common way to "initialize" a struct variable, or a variable containing
a reference to a struct, is to create a struct literal

Another way is to create a constructor with new

x := new(int)

new expression allocates a zero value of the requested type and returns a pointer to it
---------------------------------------------------------------------------------------

/* new-struct-initializer.go */
package main

import "fmt"

type Bootcamp struct {
    Lat float64
    Lon float64
}

func main() {
    x := new(Bootcamp)
    y := &Bootcamp{}
    fmt.Println(*x == *y)
}

$ go run new-struct-initializer.go
true

new is Go's built-in function that allocates memory
new does not initialize the memory, new only zeros it

new(T) allocates zeroed storage for a new item of Type T and
returns its address, a value of type *T

i.e. new returns a pointer to a newly allocated zero value of type T

NOTE:
Slices, Maps, and Channels are usually allocated using the built-in function make
so that the data structure these types are built upon can be initialized

Composition Vs Inheritance
==========================

Go does not support inheritance
Instead we have to think in terms of composition and interfaces

Composition or embedding is a well understood concept of most OOP programs

Ex:

/* composition.go */
package main

import "fmt"

type User struct {
    Id int
    Name string
    Location string
}

type Player struct {
    User
    GameId int
}

func main() {
    p := Player{}
    p.Id = 42
    p.Name = "Sujai"
    p.Location = "KA"
    p.GameId = 90404
    fmt.Printf("%+v", p)
}

$ go run composition.go
{User:{Id:42 Name:Sujai Location:KA} GameId:90404}

Here the Player struct has the same fields as the User struct,
but it also has a GameId field, we have simplified by composing our Player struct

We can initialize a new variable of type Player in two different ways

1. Using the dot notation as in the above example
2. Using a struct literal as in the below example

/* composing-struct-literal.go */
package main

import "fmt"

type User struct {
    Id int
    Name, Location string
}

type Player struct {
    User
    GameId int
}

func main() {
    /* Initialising with struct literal */
    p := Player{ User{Id: 42, Name: "Matt", Location: "LA"}, 90404,}
    
    fmt.Printf("Id: %d, Name: %s, Location: %s, Game Id: %d\n",
                p.Id, p.Name, p.Location, p.GameId)

    /* Directly set a field name on the Player struct */
    p.Id = 11
    fmt.Printf("Id: %d, Name: %s, Location: %s, Game Id: %d\n",
                p.Id, p.Name, p.Location, p.GameId)
}

$ go run composing-struct-literal.go
Id: 42, Name: Matt, Location: LA, Game Id: 90404
Id: 11, Name: Matt, Location: LA, Game Id: 90404

Because the Player struct is composed of User struct,
methods on User struct are also available to the Player struct
--------------------------------------------------------------

Ex:

/* composition-method.go */
package main

import "fmt"

type User struct {
    Id int
    Name, Location string
}

/* method on pointer to User that returns a string */
func (u *User) Greetings() string {
    return fmt.Sprintf("Hi %s from %s", u.Name, u.Location)
}

type Player struct {
    User
    GameId int
}

func main() {
    /* Initialising with dot notation */
    p1 := Player{}
    p1.Id = 42
    p1.Name = "Sai"
    p1.Location = "KA"
    p1.GameId = 90404

    /* Initialising with struct literal */
    p2 := Player{ User{Id: 42, Name: "Sujai", Location: "TVM"}, 90404,}

    fmt.Println(p1.Greetings())
    fmt.Println(p2.Greetings())
}

$ go run 
Hi Sai from KA
Hi Sujai from TVM

Composition is a very powerful way to build data structures
Its even more interesting when we think about it in the context of interfaces

-------------------------------------------------------------------------------
By composing our structure with a structure that implements a given interface,
our structure automatically implements the interface
-------------------------------------------------------------------------------

In the below example we will look at implementing a Job struct
that can also behave as a logger

package main

import (
    "log"
    "os"
)

type Job struct {
    Command string
    Logger *log.Logger
}

func main() {
    job := &Job{"demo", log.New(os.Stderr, "Job: ", log.Ldate)}
    job.Logger.Print("Test Message")
}

$ go run
Job: 2015/5/7 Test Message

Here the Job struct has a field Logger which is a pointer to another type log.Logger
We set the value of Logger during initialization,
so we are able to call its Print function by chaining calls

   job.Logger.Print()

Go lets us to go even further and use implicit composition

If we skip defining the field for our logger,
then all methods available on a pointer to log.Logger are available from our struct

Ex:

/* implicit-composition.go */
package main

import "log"
import "os"

type Job struct {
    Command string
    *log.Logger
}

func main() {
    job := &Job{"demo", log.New(os.Stderr, "Job: ", log.Lfate)}
    job.Print("Starting now...")
}

Note that we still need to set the logger
What is really nice with the implicit composition is that it allows us to
cheaply and easily make our struct implement interfaces


NOTE:
-----
It is better to compose the Player with a pointer to User struct,
because in Go arguments are passed by value, and our User struct will have
to be copied which is expensive

Below example uses pointer to User struct for composing

/* composing-pointer.go */
package main

import "fmt"

type User struct {
    Id int
    Name, Location string
}

func (u *User) Greetings() string {
    return fmt.Sprintf("Hi %s from %s\n", u.Name, u.Location)
}

type Player struct {
    *User
    GameId int
}

/*************************************/
/* constructor for the Player struct */
func NewPlayer(id int, name, location string, gameId int) *Player {
    return &Player{
        User: &User{id, name, location},
        GameId: gameId,
    }
}

func main() {
    p := NewPlayer(35, "Sujai", "KA", 9611896909)
    fmt.Println(p.Greetings())
}

**************
IMPORTANT NOTE
Methods defined on a pointer are also automatically available on the value itself

------------
Chapter Four
------------

Collection Types
================

Arrays
======

[n]T is an array of n values of type T

var a [10]int

statement above declares a variable a as an array of ten integers

An array's length is part of its type, so arrays can't be resized

/* array-example.go */
package main

import "fmt"

func main() {
    var a [2]string
    a[0] = "Hello"
    a[1] = "World"
    fmt.Println(a[0], a[1])
    fmt.Println(a)
}

$ go run array-example.go
Hello World
[Hello World]

we can also set the array entries as we declare it, like in the below example

/* array-example2.go */
package main

import "fmt"

func main() {
    a := [2]string{"hello", "world"}
    fmt.Printf("%q",a)
}

$ go run array-example2.go
["hello" "world"]


We can use allipsis to use an implicit length when passing the values

/* array-example3.go */
package main

import "fmt"

func main() {
    a := [...]string{"hello", "world"}
    fmt.Printf("%q",a)
}

$ go run array-example3.go
["hello" "world"]

NOTE:
here we have used the Printf function from fmt package and used %q verb
to print each element quoted, using %s verb we would have seen a different result

/* array-printing.go */
package main

import fmt

func main() {
    a := [2]string{"hello", "world!"}
    fmt.Println(a)
    fmt.Printf("%s\n", a)
    fmt.Printf("%q\n", a)
}

$ go run array-print.go
[hello world!]
[hello world!]
["hello" "world!"]

Multi-Dimentional Arrays
========================

/* two-dim-array.go */
package main

import "fmt"

func main() {
    var a [2][3]string

    for i := 0; i < 2; i++ {
        for j := 0; j < 3; j++ {
            a[i][j] = fmt.Sprintf("row%d-column%d", i+1, j+1)
        }
    }

    fmt.Printf("%q", a)
}

$ go run two-dim-array.go
[["row1-column1" "row1-column2" "row1-column3"] ["row2-column1" "row2-column2" "row2-column3"]]

NOTE:
Trying to access of set a value at an index that does not exist will throw array out of
bound error at compile time


Slices
======

Slices wrap arrays to give a more general, powerful, and convenient interface to sequences of data
Most array programming in Go is done with slices

Slices hold references to an underlying array, and if we assign one slice to another slice
both the slices refer to the same underlying array

If a function takes slice argument,
changes the function makes to the elements of the slice will be visible to the caller
i.e. this is same as passing a pointer to the underlying array

Slice points to an array of values ans also includes a length,
but slices can be resized as they are just a wraper on top of another data structure

[]T is a slice with elements of type T

/* slice-example.go */
package main

import "fmt"

func main() {
    p := []int{1,2,3}
    fmt.Println(p)

    for i := 0; i < len(p); i++ {
        fmt.Printf("p[%d] == %d\n", i, p[i])
    }
}

$ go run slice-example.go
[1 2 3]
p[0] == 1
p[1] == 2
p[2] == 3

Slicing a slice
===============

Slices can be re-sliced, creating a new slice value that points to the same array

s[lo:hi]
this expression evaluates to a slice of elements from lo through hi-1, inclusive

s[lo:lo]
this expression is empty

s[lo:lo+1]
resulting slice has one element

NOTE: lo and hi are integers representing indexes

package main

import "fmt"

func main() {
    mySlice := []int{2,3,5,7,11,13}
    fmt.Println(mySlice)
    // [2 3 5 7 11 13]

    fmt.Println(mySlice[1:4])
    // [3 5 7]

    // missing low index implies 0
    fmt.Println(mySlice[:3])
    // [2 3 5]

    // missing hi index implies les(s)
    fmt.Println(mySlice[4:])
    // [11 13]
}

Making Slices
=============

we can also create empty slices by using the built-in make
we have to then populate each entry

package main

import "fmt"

func main() {

    cities := make([]string, 3)
    cities[0] = "Santa Monica"
    cities[1] = "Bangalore"
    cities[2] = "Los Angeles"

    fmt.Printf("%q", cities)
    // ["Santa Monica" "Bangalore" "Los Angeles"]
}

make works by alocating a zero array and returning a slice that refers to it

Appending to a Slice
====================

cities := []string{} // empty slice
cities[0] = "Santa Monica"

we will get a runtime error if we try to append to a slice like this
"panic: runtime error: index out of range"

A we saw earlier, a slice is seating on top of an array
in this case the array is empty and the slice can't set a value in the referred array


we should use append function to add elements to a slice
--------------------------------------------------------

/* slice-append.go */
package main

import "fmt"

func main() {

    cities := []string{}
    cities = append(cities, "San Diego")
    fmt.Println(cities)
    // [San Diego]
}

We can append more than one entry to a slice

package main

import "fmt"

func main() {

    cities := []string{}
    cities = append(cities, "San Diego", "Bangalore", "Santa Monica")
    fmt.Println(cities)
}

We can append one slice to another using ellipsis (...)

package main

import "fmt"

func main() {

    cities := []string{"Santa Monica", "Santa Barbara"}
    indianCities = []string{"Bangalore", "Chennai"}
    cities = append(cities, indianCities...)
    fmt.Println(cities)
}

NOTE:
ellipsis (...) is a built-in feature of the language
... means "each element of the collection"

Usually we can't append a slice of strings to a slice of strings
only strings can be appended to a slice of string

However, using the ellipsis (...) after our slice, we indicate that
we want to append each element of our slice


Length of a Slice
=================

We can check the length of a slice by using the len function at any time

/* slice-length.go */
package main

import "fmt"

func main() {
    cities := []string{ "Santa Monica", "Santa Fee", "Santa Clara", }
    fmt.Println(len(cities))
    // 3

    zipcodes := make([]string, 42)
    fmt.Println(len(zipcodes))
    // 42
}

Nil Slices
==========

Zero value of a slice is nil, A nil slice has a length and capacity of 0

/* nil-slice.go */
package main

import "fmt"

func main() {

    var z []int
    fmt.Println(z, len(z), cap(z))
    // [] 0 0

    if z == nil {
        fmt.Println("nil!")
    }
    // nil!
}

Range
=====

range form of for loop iterates over a slice or a map
range simplifies iterating over all the elements of slice and map

/* range-example.go */
package main

import "fmt"

var pow = []int{1, 2, 4, 8, 16}

func main() {

    /* here i is the index and v is the value */
    for i, v := range pow {
        fmt.Printf("2**%d = %d\n", i,v)
    }
}

$ go run range-example.go
2**0 = 1
2**1 = 2
2**2 = 4
2**3 = 8
2**4 = 16

We can skip the index or value by assigning to _
If we only want the index, we can drop the value entirely

/* range-index-value.go */
package main

import "fmt"

func main() {
    pow := make([]int, 10)
    for i := range pow {
        pow[i] = 1 << uint(i)
    }
    for _, value := range pow {
        fmt.Printf("%d ", value)
    }
    fmt.Println()
}

$ go run range-index-value.go
1 2 4 8 16 32 64 128 256 512

Break and Continue
==================

BREAK
*****
we can stop the iteration anytime using "break"

/* range-break.go */
package main

import "fmt"

func main() {
    pow := make([]int, 10)
    for i := range pow {
        pow[i] = 1 << uint(i)
        if pow[i] >= 16 {
            break
        }
    }
    fmt.Println(pow)
}

$ go run range-break.go
[1 2 4 8 16 0 0 0 0 0]

CONTINUE
********

continue is used to skip an iteration

/* range-continue.go */
package main

import "fmt"

func main() {
    pow := make([]int, 10)
    for i := range pow {

        /* jump to next element if index is divisible by 2 */ 
        if i%2 == 0 {
            continue
        }

        pow[i] = 1 << uint(i)
    }
    fmt.Println(pow)
}

$ go run range-continue.go
[0 2 0 8 0 32 0 128 0 512]

Range and Maps
==============

Range can also be used on maps
when used on maps, first parameter returned is the key and second parameter is the value

/* range-map.go */
package main

import "fmt"

func main() {
    cities := map[string]int{
        "New York": 8336697,
        "Los Angeles": 3857799,
        "Chicago": 2714856,
    }
    for key, value := range cities {
        fmt.Printf("%s has %d inhabitants\n", key, value)
    }
}

$ go run range-map.go
Chicago has 2714856 inhabitants
New York has 8336697 inhabitants
Los Angeles has 3857799 inhabitants

Exercise:
=========
Organise the elements of a string slice based on their length
output should be a silice of slice of strings,
each string should be grouped along with other strings of same length

/* range-slice-ex.go */
package main

import "fmt"

var names = []string{"A", "AD", "BC", "Pi", "LXC", "Ctl", "Matt", "John", "Emma", "Antonio", "Samantha","Alveres", "Viking", "Kruger", "Addison", "Isabella"}

func main() {
    var maxLen int
    for _, name := range names {
        if l := len(name); l > maxLen {
            maxLen = l
        }
    }

    output := make([][]string, maxLen)
    fmt.Println(len(output))
    for _, name := range names {
        output[len(name)-1] = append(output[len(name)-1], name)
    }

    fmt.Printf("%v", output)
    fmt.Println()
}

$ go run range-slice-ex.go
8
[[A] [AD BC Pi] [LXC Ctl] [Matt John Emma] [] [Viking Kruger] [Antonio Alveres Addison] [Samantha Isabella]]

NOTE:
To avoid an out of bound insert we need our output slice to be big enough
That is why we made a first pass through all strings and found the longest

Slices are zeor indexed, so when inserting the strings we insert it at length-1

Maps
====

maps are similar to dictionaries in other languages

in the below example we are mapping string city names to an integer std codes

/* map-ex.go */
package main

import "fmt"

func main() {

    cities := map[string]int{
        "Bangalore": 80,
        "Chennai": 44,
        "Mumbai": 22,
        "Delhi": 11,
    }
    fmt.Printf("%#v", cities)
}

$ go run map-ex.go
map[string]int{"Chennai":44, "Mumbai":22, "Delhi":11, "Bangalore":80}

When not using map literals like above, we must create maps with make
The nil map is empty and can not be assigned to

Assignments should follow Go convention like in the below example

package main

import "fmt"

type Vertex struct {
    Lat, Lon float64
}


func main() {

    m := make(map[string]Vertex)
    m["Bell Labs"] = Vertex{40.68433, -74.39967}
    fmt.Println(m["Bell Labs"])

}

NOTE:
When using map litterals, if the top-level type is just a type name,
the we can ommit it from the elements of the literal

Ex:

package main

import "fmt"

type Vertex struct {
    Lat, Lon float64
}

var m = map[string]Vertex{
    "Bell Labs": {40.68433, -74.39967},
    "Google": {37.42202, -122.08408},
}

func main() {
    fmt.Println(m)
}

Mutating Maps
=============

Insert or Update an element in map m: m[key] = elem

Retrive an element: elem = m[key]

Delete an element: delete(m, key)

Test if a key is present: elem, ok = m[key]
In this case if key is in m, then ok is true, if not ok is false



Control Flow
============


IF Statement
------------

If statement is same as C, except that the () are gone, and the {} are required

like for, if statement can start with a short statement to execute before the condition

variables declared by the statement are only in scope until the end of the if

variables declared inside an if short statement are also available inside any of the else blocks

Ex:

/* If statement */
if answer != true {
    return "wrong answer"
}


/* If with a short statement */
if err := foo(); err != nil {
    panic(err)
}

/* If and else statement */
if v := math.Pow(x, n); v < lim {
    return v
} else {
    fmt.Println("%g >= %g\n", v, lim)
}

FOR Loop
--------

Go has only one looping construct, the for loop

for loop is same as C, except that () are gone, and the {} are required

As in C or Java, we can leave the pre and post statements empty

Ex:
/* for loop */
sum := 0
for i := 0, i < 10; i++ {
    sum += i
}

/* for loop without pre and post */
sum := 1
for ; sum < 1000; {
    sum += sum
}

/* for loop as a while loop */
sum := 1
for sum < 1000 {
    sum += sum
}

/* infinite loop */
for {
  fmt.Println("Do something forever")
}


Switch Case
-----------

switch case statement allows us to avoid doing complex series of if else statements

Ex:

package main

import "fmt"
import "time"

func main() {
    now := time.Now().Unix()
    mins := now % 2
    switch mins {
    case 0:
        fmt.Println("even")
    case 1:
        fmt.Println("odd")
    }
}

Few Notes About Switch Case:
****************************
We can only compare values of the same type
We can set an optional default statement to be executed if all others fail
We can use an expression in the case statement
  i.e. for instance we can calculate a value to use in the case
We can have multiple , seperated values per case
We can execute all the following statements after a match using fallthrough statement
We can use a break statement inside our matched statement to exit the switching process

/* expressions in case */
package main

import "fmt"

func main() {
    num := 3
    v := num % 2
    switch v {
    case 0:
        fmt.Println("even")
    /* expression in case */
    case 3 - 2:
        fmt.Println("odd")
    }
}


/* multiple values in case */
package main

import "fmt"

func main() {
    score := 7
    switch score {
    case 0, 1, 3:
        fmt.Println("Terrible")
    case 4, 5:
        fmt.Println("Mediocre")
    case 6, 7:
        fmt.Println("Not bad")
    case 8, 9:
        fmt.Println("Almost perfect")
    case 10:
        fmt.Println("hmm did you cheat?")
    default:
        fmt.Println(score, " off the chart")
    }
}

/* fallthrough and break */
package main

import "fmt"
import "time"

func main() {
    n := 1
    switch n {
    case 0:
        fmt.Println("is zero")
        fallthrough
    case 1:
        fmt.Println("<= 1")
        fallthrough
    case 2:
        fmt.Println("<= 2")
        fallthrough
    case 3:
        fmt.Println("<= 3")
        if time.Now().Unix() % 2 == 0 {
            fmt.Println("un pasito pa lante maria")
            break
        }
        fallthrough
    case 4:
        fmt.Println("<= 4")
    }
}

**********
Excercise:
**********
We have 50 bitcoins to distribute to 10 users
Coins will be distributed based on vowels contained in each name

Where:
A: 1 Coin, E: 1 Coin, I: 2 Coins, O:, 3 coins, and U: 4 coins

And each user can't get more than 10 coins

Users:
Matthew, Sarah, Augustus, Heidi, Emilie, Peter, Giana, Adriano, Aaron, and Elizabeth


/* Solution */
package main

import "fmt"

var (
    coins = 50
    users = []string{
        "Matthew", "Sarah", "Augustus", "Heidi", "Emilie",
        "Peter", "Giana", "Adriano", "Aaron", "Elizabeth",
    }
    distribution = make(map[string]int, len(users))
)

func main() {

    coinsForUser := func(name string) int {
        var total int
        for i := 0; i < len(name); i++ {
            switch string(name[i]) {
            case "a", "A", "e", "E":
                total++
            case "i", "I":
                total = total + 2
            case "o", "O":
                total = total + 3
            case "u", "U":
                total = total + 4
            }
        }
        return total
    }

    for _, name := range users {
        v := coinsForUser(name)
        if v > 10 {
            v = 10
        }
        distribution[name] = v
        coins = coins - v
    }

    fmt.Println(distribution)
    fmt.Println("Coins left:", coins)

}

Methods
=======

Technically Go is not an Object Oriented Programming Language
But, Types and Methods allow for an object-orientd style of programming

No Inheritance
**************
Difference with other OO languages is that Go does not support type inheritance
instead Go has a concept of interfaces

A method is a function that has a defined receiver.
in Go, we can define methods on struct types

The method receiver appears in its own argument list between the func keyword and the method name

Example:

package main

import "fmt"

type User struct {
    FirstName, LastName string
}

func (u User) Greeting() string {
    return fmt.Sprintf("Dear %s %s", u.FirstName, u.LastName)
}

func main() {
    u := User{"Sujai", "Prakasam"}
    fmt.Println(u.Greeting())
}

NOTE:
Unlike in other OO languages, methods are written outside of the struct
i.e. the Greeting() method on User type could be defined anywhere in the package

Code Organization
=================
Methods can be definedin any file in the package,
but recommendation is to organize the code as shown below

Example:

package models

//list of packages to import
import (
    "fmt"
)

// list of constants
const (
    ConstExample = "const before vars"
)

// list of variables
var (
    ExportedVar = 42
    nonExportedVar = "so say we all"
)

// Main type(s) for the file
// Try to keep the lowest amount of structs per file when possible
type User struct {
    FirstName, LastName string
    Location *UserLocation
)

type UserLocation struct {
    City, Country string
}

// List of Functions
func NewUser(firstName, lastName string) *User {
    return &User{FirstName: firstName, LastName: lastName,
        Location: &UserLocation{City: "Santa Clara", Country: "USA",},
    }
}

// List of Methods
func (u *User) Greeting() string {
    return fmt.Sprintf("Dear %s %s", u.FirstName, u.LastName)
}

Note:
We can define a method on any type we define in our package
We can't define a method on a basic type, or a type from another package

Type Aliasing
=============

To define a method on a type that we don't own,
we need to define an alias for the type we want to extend

Example:

package main

import "fmt"
import "strings"

type MyStr string

func (s MyStr) Uppercase() string {
    return strings.ToUpper(string(s))
}

func main() {
    fmt.Println(MyStr("test").Uppercase())
}


Example:

package main

import "fmt"
import "math"

type MyFloat float64

// method that returns an absolute value of type float6
func (f MyFloat) Abs() float64 {
    if f < 0 {
        return float64(-f)
    }
    return float644(f)
}

func main() {
    f := MyFloat(-math.Sqrt2)
    fmt.Println(f.Abs())
}

Method Receivers
================

Methods can be associated with a named type, or a pointer to a named type

There are two reasons to use a pointer receiver
> To avoid copying the value on each method call
> So that the method can modify the value that its receiver points to

Remember, by default Go passes everything by value

Example:

package main

import "fmt"

type User struct {
    FirstName, SecondName string
}

func (u *User) Greeting() string {
    return fmt.Sprintf("Dear %s %s", u.FirstName, u.SecondName)
}

func main() {
    u := &User{"Sujai", "Prakasam"}
    fmt.Println(u.Greeting())
}


Example:

package main

import "fmt"
import "math"

type Vertex struct {
    X, Y float64
}

// This method modifies the receiver value
// so it must be defined on a pointer type
func (v *Vertex) Scale(f float64) {
    v.X = v.X * f
    v.Y = v.Y * f
}


// This method does not modify the receiver value
// so it can be defined on value type
func (v *Vertex) Abs() float64 {
    return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func main() {
    v := &Vertex{3, 4}
    v.Scale(5)
    fmt.Println(v, v.Abs())
}

Interfaces
==========


