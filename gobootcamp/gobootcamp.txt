Variables & Inferred Typing
===========================

The var statement declares a list of variables with the type declared last

Ex:

var (
        name     string
        age      int
        location string
)

or

var (
        name, location string
        age            int
)

Variables can also be declared one by one

Ex:

var name string
var age int
var location string

var declaration can also include initializers for the variables

Ex:

var (
        name string = "My Name"
        age int = 32
        location string = "Bronx"
)

Type can be omitted if an initializer is present,
the variable will take type of the initializer (inferred typing)

Ex:

var (
        name = "My name"
        age  = 32
        location = "Bronx"
)

We can also initialize variables on the same line

Ex:

var (
        name, location, age = "My name", "Bronx", 32
)

or 

var name, location, age = "My name", "Bronx", 32


Short Assignment ( := )
=======================

The := short assignment statement can be used inside a function with implicit type,
in place of var decleration

Ex:

func main() {
    name, location, := "My name", "Bronx"
    age = 32
    fmt.Printf("%s (%d) of %s", name, age, location )
}

:= construct is not available outside a function

Functions as variables
======================

A variable can contain any type, including functions

Ex:

func main() {
    action := func() {
                  fmt.Println("Action from func!")
    }
    action()
}

Constants
=========

Constants are declared like variables, but with "const" keyword
Constants can only be character, string, boolean, or numeric values
Constants can't be declared using the := syntax
An untyped constant takes the type needed by its context

Ex:

const Pi = 3.14
const (
    StatusOk = 200
    StatusCreated = 201
    StatusAccepted = 202
    StatusNonAuthoritativeInfo = 203
    StatusNoContent = 204
    StatusResetContent = 205
    StatusPartialContent = 206
)


Ex:

/* constantExOne.go */
package main

import "fmt"

const (
    Pi = 3.14
    Truth = false
    Big = 1 << 100
    Small = Big >> 99
)

func main() {
    const Greeting = "Hello There"
    fmt.Println(Greeting)
    fmt.Println(Pi)
    fmt.Println(Truth)
}

fmt.Println prints the passed variable or constants value and appends a newline
fmt.Printf is used when we want to print values using format specifiers

Ex:

func main() {
    name := "Caprica-Six"
    aka := fmt.Sprintf("Number %d", 6)
    fmt.Printf("%s is also known as %s", name, aka)
}

Packages and imports
====================

Every Go program is made up of packages
Programs start running in package main

Ex:

package main

func main() {
    print("Hello, World!\n")
}

If we are writing an executable code (versus a library), then we need to define
a main package and a main() function which will be the entry point in to our software

For imported packages, the package name is the same as the last element of the
import path by convention.

Ex:

import "math/rand"

the "math/rand" package comprises files that begin with statement "package rand"

import statements can be individual or grouped

Ex:

import "fmt"
import "math/rand"

or

import (
    "fmt"
    "math/rand"
)

Non standard library packages are usually namespaced using a web url.

For instance, Go port of Rails 4 cryptography is hosted at the below url
http://github.com/mattetti/goRailsYourself

To import the crypto package, we would use the below import statement

import "github.com/mattetti/goRailsYourself/crypto"

this tells the compiler to import the crypto package available at the github path
it does not mean that the compiler will automatically pull down the repo

we will need to pull down the code ourself, easiest way is to use the "go get" command

$ go get github.com/mattetti/goRailsYourself/crypto

This command will pull the code and put it in our Go path.
GOPATH environment variable is usually set when we install GO


We should store our code (our workspace) under GOPATH
$ ls $GOPATH
bin  pkg  src

bin folder will contain compiled Go binaries,
we should probably add the bin path to our system path

pkg folder contains the compiled versions of the available libraries,
so the compiler can link against them without recompiling them

src folder contains all the Go source code organized by import path

$ ls $GOPATH/src
bitbucket.org   code.google.com   github.com

$ ls $GOPATH/src/github.com/mattetti
goblin  goRailsYourself  jet

Its recomended to start a new project inside the src folder,
using a fully qualified path
for instance: github.com/<our username>/<project name>

Exported Names
==============

After importing a package we can refer to the names the package exports
i.e. variables, methods, and functions that are available for use

In Go, a name is exported if it begins with a capital letter
FOO and Foo are exported names, foo is not a exported name

Ex:

package main

import (
    "fmt"
    "math"
)

func main() {
    fmt.Println(math.pi)
}

Running this will give the below error
"cannot refer to unexported name math.pi"

i.e. pi is not exported, we should use Pi which is exported and available for use

func main() {
    fmt.Println(math.Pi)
}


Functions, signature, return values, named results
==================================================

A function can take zero or more typed arguments
The type comes after the variable name
Functions can be defined to return any number of values
Function return values are always typed

Ex:

package main

import "fmt"

/* Function takes two int arguments and returns an int value */
func add(x, y int) int {
    return x + y
}

func main() {
    fmt.Println(add(42, 13))
}


location function in the below example returns two string values

package main

import "fmt"

func location(city string) (string, string) {
    var region string
    var country string

    switch city {
    case "Los Angeles", "LA", "Santa Monica":
        region, country = "California", "United States"
    case "New York", "NYC":
        region, country = "New York", "United States"
    case "Bangalore", "KA":
        region, country = "South India", "Republic of India"
    default:
        region, country = "Unknown", "Unknown"
    }
    return region, country
}

func main() {
    mattregion, mattcountry := location("Santa Monica")
    fmt.Printf("Matt lives in %s, %s\n", mattregion, mattcountry )
    myregion, mycountry := location("Bangalore")
    fmt.Printf("Sujai lives in %s, %s\n", myregion, mycountry)
}


Functions can return multiple "result parameters"
Function return values can be named just like variables

If the result parameters are named, then
a return statement without arguments returns the current values of the results

Ex:

package main

import "fmt"

func location(namein, city string) (name, country string) {
    name = namein
    switch city {
    case "New York", "LA", "Chicago":
        country = "United States"
    case "Bangalore", "Chennai", "Mumbai":
        country = "Republic of India"
    default:
        country = "Unknown"
    }
    return
}

func main() {
    myname, mycountry := location("Sujai", "Bangalore")
    fmt.Printf("%s lives in %s\n", myname, mycountry)
    mattname, mattcountry := location("Matt", "LA")
    fmt.Printf("%s lives in %s\n", mattname, mattcountry)
}

Recomendation is to avoid named return parameters as they often cause more
confusion than the time saved, and distrub the clarity of our code

Pointers
========

Go has pointers, but no pointer arithmatic :)

Struct fields can be accessed through a struct pointer
Indirection through pointer is transparent
We can directly call fields and methods on a pointer

By default Go passes arguments by value, copying the arguments
If we want to pass arguments by reference, we need to pass pointers

Go's inbuilt data structures like slices and maps use reference values

Use & symbol in front of the value, to get the pointer of a value.
Use * symbol to derefrence a pointer

Methods are often defined on pointers than on values,
so we will often store a pointer in a variable as in the below snippet

client := &http.Client{}
resp, err := client.Get("http://gobootcamp.com")

Mutability
==========

Only constants are immutable in Go

However because arguments are passed by value,
a function receiving a value argument and mutating it won't mutate the original

Ex:

/* pass-by-value.go */
package main

import "fmt"

type Artist struct {
    Name, Genre string
    Songs int
}

func newRelease(a Artist) int {
    a.Songs++
    return a.Songs
}

func main() {

    me := Artist{Name: "Sujai", Genre: "Tribal", Songs: 9}
    fmt.Printf("%s released his %dth song\n", me.Name, newRelease(me))
    fmt.Printf("%s has a total of %d songs\n", me.Name, me.Songs)

}

$ go run pass-by-value.go
Sujai released his 10th song
Sujai has a total of 9 songs

As we can see the total number of songs on the me variable's value was not changed

To mutate the passed value, we have to pass it by reference using a pointer

Ex:

/* pass-by-reference.go */
package main

import "fmt"

type Artist struct {
    Name, Genre string
    Songs int
}

/* Now the newRelease takes a pointer to Artist */
func newRelease(a *Artist) int {
    a.Songs++
    return a.Songs
}

func main() {

    /* here we use & symbol to get a pointer to Artist */
    me := &Artist{Name: "Sujai", Genre: "Tribal", Songs: 9}
    fmt.Printf("%s released his %dth song\n", me.Name, newRelease(me))
    fmt.Printf("%s has a total of %d songs\n", me.Name, me.Songs)

}

$ go run pass-by-reference.go
Sujai released his 10th song
Sujai has a total of 10 songs


---------------
Chapter 3 Types
---------------

Basic Types
===========

bool, string and numeric types are the basic types in Go

Numeric Types:

uint - either 32 or 64 bits
int - same as uint

uintptr - unsigned integer to store pointer value

uint8 and int8 - (0 to 255) and (-128 to 127)
uint16 and int16 - (0 to 65535) and (-32768 to 32767)
uint32 and int32 - (0 to 4294967295) and (-2147483648 to 2147483647)
uint64 and int64 - signed and unsigned 64 bit integers

float32 - set of 32 bit floating point numbers
float64 - set of 64 bit floating point numbers

complex64 and complex128 - complex numbers

byte - alias for uint8, (0 to 255)
rune - alias for int32 (represents Unicode code point)


Ex:

/* built-in-types.go */
package main

import (
    "fmt"
    "math/cmplx"
)

var (
    goIsFun bool = true
    maxInt uint64 = 1<<64 -1
    complex complex128 = cmplx.Sqrt(-5 + 12i)
)

func main() {
    const f = "%T = %v\n"
    fmt.Printf(f, goIsFun, goIsFun)
    fmt.Printf(f, maxInt, maxInt)
    fmt.Printf(f, complex, complex)
}

$ go run built-in-types.go
bool = true
uint64 = 18446744073709551615
complex128 = (2+3i)


Type Conversion
===============

The expression T(v) converts the value v to the type T

Some numeric conversions:

var i int = 42
var f float64 = float64(i)
var u uint = uint(f)

or, the same can be simplified as below when used inside a function

i := 42
f := float64(i)
u := uint(f)

Go assignment between items of different types requires an explicit conversion

i.e. we have to manually convert types if we are passing a variable to a function 
that is expecting another type


Type Assertion
==============

Type assertion takes a value and tries to create another version in the
specified explicit value

i.e. If we have a value and want to convert it to a specific type,
then we can use type assertion

In the example below, timeMap function takes a value and checks to see
if the value type can be asserted as a map of interface{} keyed by strings,
then it injects a new entry "updated_at" with the current time value

/* type-assertion.go */
package main

import "fmt"
import "time"

func timeMap(myval interface{}) {
    val, ok := myval.(map[string]interface{})
    if ok {
        val["updated_at"] = time.Now()
    }
}

func main() {
    foo := map[string]interface{}{
        "Matt": 42,
    }
    timeMap(foo)
    fmt.Println(foo)
}


Type assertion is often used when we have a function that takes
a parameter of a specific interface, but the function behaves 
differently based on the actual parameter type

Ex:

package main

import "fmt"

/* Stringer interface */
type Stringer interface {
    String() string
}

type fakeString struct {
    content string
}

/* Function String of fakeString struct that returns a string */
/* This function implements the stringer interface */
func (s *fakeString) String() string {
    return s.content
}

/* interface{} is a empty interface, that doesn't contain any method */
/* every type implements all 0 methods of the empty interface */
/* A function that takes a parameter of type interface{} in reality accepts any type */
func printString(value interface{}) {
    switch str := value.type() {
    case string:
        fmt.Println(str)
    case Stringer:
        fmt.Println(str.String())
    }
}

func main() {
    s := &fakeString{"I love Go"}
    printString(s)
    printString("Hello, Gophers")
}


Another use of Type assertion is when checking if an error is of certain type

if err != nil {
  if msqlerr, ok := err.(*mysql.MySQLError); ok && msqlerr.Number == 1062 {
      log.Println("We got a MySQL duplicate !")
  } else {
      return err
  }
}

