Variables & Inferred Typing
===========================

The var statement declares a list of variables with the type declared last

Ex:

var (
        name     string
        age      int
        location string
)

or

var (
        name, location string
        age            int
)

Variables can also be declared one by one

Ex:

var name string
var age int
var location string

var declaration can also include initializers for the variables

Ex:

var (
        name string = "My Name"
        age int = 32
        location string = "Bronx"
)

Type can be omitted if an initializer is present,
the variable will take type of the initializer (inferred typing)

Ex:

var (
        name = "My name"
        age  = 32
        location = "Bronx"
)

We can also initialize variables on the same line

Ex:

var (
        name, location, age = "My name", "Bronx", 32
)

or 

var name, location, age = "My name", "Bronx", 32


Short Assignment ( := )
=======================

The := short assignment statement can be used inside a function with implicit type,
in place of var decleration

Ex:

func main() {
    name, location, := "My name", "Bronx"
    age = 32
    fmt.Printf("%s (%d) of %s", name, age, location )
}

:= construct is not available outside a function

Functions as variables
======================

A variable can contain any type, including functions

Ex:

func main() {
    action := func() {
                  fmt.Println("Action from func!")
    }
    action()
}

Constants
=========

Constants are declared like variables, but with "const" keyword
Constants can only be character, string, boolean, or numeric values
Constants can't be declared using the := syntax
An untyped constant takes the type needed by its context

Ex:

const Pi = 3.14
const (
    StatusOk = 200
    StatusCreated = 201
    StatusAccepted = 202
    StatusNonAuthoritativeInfo = 203
    StatusNoContent = 204
    StatusResetContent = 205
    StatusPartialContent = 206
)


Ex:

/* constantExOne.go */
package main

import "fmt"

const (
    Pi = 3.14
    Truth = false
    Big = 1 << 100
    Small = Big >> 99
)

func main() {
    const Greeting = "Hello There"
    fmt.Println(Greeting)
    fmt.Println(Pi)
    fmt.Println(Truth)
}

fmt.Println prints the passed variable or constants value and appends a newline
fmt.Printf is used when we want to print values using format specifiers

Ex:

func main() {
    name := "Caprica-Six"
    aka := fmt.Sprintf("Number %d", 6)
    fmt.Printf("%s is also known as %s", name, aka)
}

Packages and imports
====================

Every Go program is made up of packages
Programs start running in package main

Ex:

package main

func main() {
    print("Hello, World!\n")
}

If we are writing an executable code (versus a library), then we need to define
a main package and a main() function which will be the entry point in to our software

For imported packages, the package name is the same as the last element of the
import path by convention.

Ex:

import "math/rand"

the "math/rand" package comprises files that begin with statement "package rand"

import statements can be individual or grouped

Ex:

import "fmt"
import "math/rand"

or

import (
    "fmt"
    "math/rand"
)

Non standard library packages are usually namespaced using a web url.

For instance, Go port of Rails 4 cryptography is hosted at the below url
http://github.com/mattetti/goRailsYourself

To import the crypto package, we would use the below import statement

import "github.com/mattetti/goRailsYourself/crypto"

this tells the compiler to import the crypto package available at the github path
it does not mean that the compiler will automatically pull down the repo

we will need to pull down the code ourself, easiest way is to use the "go get" command

$ go get github.com/mattetti/goRailsYourself/crypto

This command will pull the code and put it in our Go path.
GOPATH environment variable is usually set when we install GO


We should store our code (our workspace) under GOPATH
$ ls $GOPATH
bin  pkg  src

bin folder will contain compiled Go binaries,
we should probably add the bin path to our system path

pkg folder contains the compiled versions of the available libraries,
so the compiler can link against them without recompiling them

src folder contains all the Go source code organized by import path

$ ls $GOPATH/src
bitbucket.org   code.google.com   github.com

$ ls $GOPATH/src/github.com/mattetti
goblin  goRailsYourself  jet

Its recomended to start a new project inside the src folder,
using a fully qualified path
for instance: github.com/<our username>/<project name>

Exported Names
==============

After importing a package we can refer to the names the package exports
i.e. variables, methods, and functions that are available for use

In Go, a name is exported if it begins with a capital letter
FOO and Foo are exported names, foo is not a exported name

Ex:

package main

import (
    "fmt"
    "math"
)

func main() {
    fmt.Println(math.pi)
}

Running this will give the below error
"cannot refer to unexported name math.pi"

i.e. pi is not exported, we should use Pi which is exported and available for use

func main() {
    fmt.Println(math.Pi)
}


Functions, signature, return values, named results
==================================================

A function can take zero or more typed arguments
The type comes after the variable name
Functions can be defined to return any number of values
Function return values are always typed

Ex:

package main

import "fmt"

/* Function takes two int arguments and returns an int value */
func add(x, y int) int {
    return x + y
}

func main() {
    fmt.Println(add(42, 13))
}


location function in the below example returns two string values

package main

import "fmt"

func location(city string) (string, string) {
    var region string
    var country string

    switch city {
    case "Los Angeles", "LA", "Santa Monica":
        region, country = "California", "United States"
    case "New York", "NYC":
        region, country = "New York", "United States"
    case "Bangalore", "KA":
        region, country = "South India", "Republic of India"
    default:
        region, country = "Unknown", "Unknown"
    }
    return region, country
}

func main() {
    mattregion, mattcountry := location("Santa Monica")
    fmt.Printf("Matt lives in %s, %s\n", mattregion, mattcountry )
    myregion, mycountry := location("Bangalore")
    fmt.Printf("Sujai lives in %s, %s\n", myregion, mycountry)
}


Functions can return multiple "result parameters"
Function return values can be named just like variables

If the result parameters are named, then
a return statement without arguments returns the current values of the results

Ex:

package main

import "fmt"

func location(namein, city string) (name, country string) {
    name = namein
    switch city {
    case "New York", "LA", "Chicago":
        country = "United States"
    case "Bangalore", "Chennai", "Mumbai":
        country = "Republic of India"
    default:
        country = "Unknown"
    }
    return
}

func main() {
    myname, mycountry := location("Sujai", "Bangalore")
    fmt.Printf("%s lives in %s\n", myname, mycountry)
    mattname, mattcountry := location("Matt", "LA")
    fmt.Printf("%s lives in %s\n", mattname, mattcountry)
}

Recomendation is to avoid named return parameters as they often cause more
confusion than the time saved, and distrub the clarity of our code

Pointers
========

Go has pointers, but no pointer arithmatic :)

Struct fields can be accessed through a struct pointer
Indirection through pointer is transparent
We can directly call fields and methods on a pointer

By default Go passes arguments by value, copying the arguments
If we want to pass arguments by reference, we need to pass pointers

Go's inbuilt data structures like slices and maps use reference values

Use & symbol in front of the value, to get the pointer of a value.
Use * symbol to derefrence a pointer

Methods are often defined on pointers than on values,
so we will often store a pointer in a variable as in the below snippet

client := &http.Client{}
resp, err := client.Get("http://gobootcamp.com")

Mutability
==========

Only constants are immutable in Go

However because arguments are passed by value,
a function receiving a value argument and mutating it won't mutate the original

Ex:

/* pass-by-value.go */
package main

import "fmt"

type Artist struct {
    Name, Genre string
    Songs int
}

func newRelease(a Artist) int {
    a.Songs++
    return a.Songs
}

func main() {

    me := Artist{Name: "Sujai", Genre: "Tribal", Songs: 9}
    fmt.Printf("%s released his %dth song\n", me.Name, newRelease(me))
    fmt.Printf("%s has a total of %d songs\n", me.Name, me.Songs)

}

$ go run pass-by-value.go
Sujai released his 10th song
Sujai has a total of 9 songs

As we can see the total number of songs on the me variable's value was not changed

To mutate the passed value, we have to pass it by reference using a pointer

Ex:

/* pass-by-reference.go */
package main

import "fmt"

type Artist struct {
    Name, Genre string
    Songs int
}

/* Now the newRelease takes a pointer to Artist */
func newRelease(a *Artist) int {
    a.Songs++
    return a.Songs
}

func main() {

    /* here we use & symbol to get a pointer to Artist */
    me := &Artist{Name: "Sujai", Genre: "Tribal", Songs: 9}
    fmt.Printf("%s released his %dth song\n", me.Name, newRelease(me))
    fmt.Printf("%s has a total of %d songs\n", me.Name, me.Songs)

}

$ go run pass-by-reference.go
Sujai released his 10th song
Sujai has a total of 10 songs


---------------
Chapter 3 Types
---------------

Basic Types
===========

bool, string and numeric types are the basic types in Go

Numeric Types:

uint - either 32 or 64 bits
int - same as uint

uintptr - unsigned integer to store pointer value

uint8 and int8 - (0 to 255) and (-128 to 127)
uint16 and int16 - (0 to 65535) and (-32768 to 32767)
uint32 and int32 - (0 to 4294967295) and (-2147483648 to 2147483647)
uint64 and int64 - signed and unsigned 64 bit integers

float32 - set of 32 bit floating point numbers
float64 - set of 64 bit floating point numbers

complex64 and complex128 - complex numbers

byte - alias for uint8, (0 to 255)
rune - alias for int32 (represents Unicode code point)


Ex:

/* built-in-types.go */
package main

import (
    "fmt"
    "math/cmplx"
)

var (
    goIsFun bool = true
    maxInt uint64 = 1<<64 -1
    complex complex128 = cmplx.Sqrt(-5 + 12i)
)

func main() {
    const f = "%T = %v\n"
    fmt.Printf(f, goIsFun, goIsFun)
    fmt.Printf(f, maxInt, maxInt)
    fmt.Printf(f, complex, complex)
}

$ go run built-in-types.go
bool = true
uint64 = 18446744073709551615
complex128 = (2+3i)


Type Conversion
===============

The expression T(v) converts the value v to the type T

Some numeric conversions:

var i int = 42
var f float64 = float64(i)
var u uint = uint(f)

or, the same can be simplified as below when used inside a function

i := 42
f := float64(i)
u := uint(f)

Go assignment between items of different types requires an explicit conversion

i.e. we have to manually convert types if we are passing a variable to a function 
that is expecting another type


Type Assertion
==============

Type assertion takes a value and tries to create another version in the
specified explicit value

i.e. If we have a value and want to convert it to a specific type,
then we can use type assertion

In the example below, timeMap function takes a value and checks to see
if the value type can be asserted as a map of interface{} keyed by strings,
then it injects a new entry "updated_at" with the current time value

/* type-assertion.go */
package main

import "fmt"
import "time"

func timeMap(myval interface{}) {
    val, ok := myval.(map[string]interface{})
    if ok {
        val["updated_at"] = time.Now()
    }
}

func main() {
    foo := map[string]interface{}{
        "Matt": 42,
    }
    timeMap(foo)
    fmt.Println(foo)
}


Type assertion is often used when we have a function that takes
a parameter of a specific interface, but the function behaves 
differently based on the actual parameter type

Ex:

package main

import "fmt"

/* Stringer interface */
type Stringer interface {
    String() string
}

type fakeString struct {
    content string
}

/* Function String of fakeString struct that returns a string */
/* This function implements the stringer interface */
func (s *fakeString) String() string {
    return s.content
}

/* interface{} is a empty interface, that doesn't contain any method */
/* every type implements all 0 methods of the empty interface */
/* A function that takes a parameter of type interface{} in reality accepts any type */
func printString(value interface{}) {
    switch str := value.type() {
    case string:
        fmt.Println(str)
    case Stringer:
        fmt.Println(str.String())
    }
}

func main() {
    s := &fakeString{"I love Go"}
    printString(s)
    printString("Hello, Gophers")
}


Another use of Type assertion is when checking if an error is of certain type

if err != nil {
  if msqlerr, ok := err.(*mysql.MySQLError); ok && msqlerr.Number == 1062 {
      log.Println("We got a MySQL duplicate !")
  } else {
      return err
  }
}


Structs
=======

Struct is a collection of fields / properties
We can define new types as structs or interfaces

Structs can be though of as light class that supports composition,
but does not support inheritance

We don't need to define getters and setters on struct fields,
they can be accessed automatically.

However only exported fields (Capitalized) of a struct can be
accessed from outside of a package

A struct literal sets a newly allocated struct value by listing
the values of its fields

We can list just a subset of fields by using the "Name:" syntax
(order of named fields is irrelevant when using this Syntax)

The special prefix & constructs a pointer to a newly allocated struct
---------------------------------------------------------------------

Ex:

/* struct-example.go */
package main

import (
    "fmt"
    "time"
)

type Bootcamp struct {
    // Latitude of the event
    Lat float64
    /// Longitude of the event
    Lon float64
    // Date of the event
    Date time.Time
}

func main() {
    fmt.Println(Bootcamp{Lat: 34.012836, Lon: -118.495338, Date: time.Now(), })
}

$ go run struct-example.go
{34.012836, -118.495338, 2015-05-07 11:37:00 +0000 UTC}


Ex:


/* decleration-of-struct-literals.go */
package main

import "fmt"

type Point struct {
    X, Y int
}

var (
    p = Point{1, 2}  // has a type Point
    q = &Point{1, 2} // has a type *Point
    r = Point{X: 1} // Y: 0 is implicit
    s = Point{} // X:0 and Y:0
)

func main() {
    fmt.Println(p, 1, r, s)
}

$ go run decleration-of-struct-literals.go
{1 2} &{1 2} {1 0} {0 0}


Accessing struct fields using the dot notation:

Ex:

/* struct-dot-notation.go */
package main()

import (
    "fmt"
    "time"
)

type Bootcamp struct {
    Lat, Lon float64
    Date time.Time
}

func main() {
    event := BootCamp{ Lat: 34.012836, Lon: -118.495338,}

    /* Dot Notation */
    event.Date = time.Now()
    fmt.Printf("Event on %s, location (%f, %f)",
            event.Date, event.Lat, event.Lon)
}


Initializing
============

Common way to "initialize" a struct variable, or a variable containing
a reference to a struct, is to create a struct literal

Another way is to create a constructor with new

x := new(int)

new expression allocates a zero value of the requested type and returns a pointer to it
---------------------------------------------------------------------------------------

/* new-struct-initializer.go */
package main

import "fmt"

type Bootcamp struct {
    Lat float64
    Lon float64
}

func main() {
    x := new(Bootcamp)
    y := &Bootcamp{}
    fmt.Println(*x == *y)
}

$ go run new-struct-initializer.go
true

new is Go's built-in function that allocates memory
new does not initialize the memory, new only zeros it

new(T) allocates zeroed storage for a new item of Type T and
returns its address, a value of type *T

i.e. new returns a pointer to a newly allocated zero value of type T

NOTE:
Slices, Maps, and Channels are usually allocated using the built-in function make
so that the data structure these types are built upon can be initialized

Composition Vs Inheritance
==========================

Go does not support inheritance
Instead we have to think in terms of composition and interfaces

Composition or embedding is a well understood concept of most OOP programs

Ex:

/* composition.go */
package main

import "fmt"

type User struct {
    Id int
    Name string
    Location string
}

type Player struct {
    User
    GameId int
}

func main() {
    p := Player{}
    p.Id = 42
    p.Name = "Sujai"
    p.Location = "KA"
    p.GameId = 90404
    fmt.Printf("%+v", p)
}

$ go run composition.go
{User:{Id:42 Name:Sujai Location:KA} GameId:90404}

Here the Player struct has the same fields as the User struct,
but it also has a GameId field, we have simplified by composing our Player struct

We can initialize a new variable of type Player in two different ways

1. Using the dot notation as in the above example
2. Using a struct literal as in the below example

/* composing-struct-literal.go */
package main

import "fmt"

type User struct {
    Id int
    Name, Location string
}

type Player struct {
    User
    GameId int
}

func main() {
    /* Initialising with struct literal */
    p := Player{ User{Id: 42, Name: "Matt", Location: "LA"}, 90404,}
    
    fmt.Printf("Id: %d, Name: %s, Location: %s, Game Id: %d\n",
                p.Id, p.Name, p.Location, p.GameId)

    /* Directly set a field name on the Player struct */
    p.Id = 11
    fmt.Printf("Id: %d, Name: %s, Location: %s, Game Id: %d\n",
                p.Id, p.Name, p.Location, p.GameId)
}

$ go run composing-struct-literal.go
Id: 42, Name: Matt, Location: LA, Game Id: 90404
Id: 11, Name: Matt, Location: LA, Game Id: 90404

Because the Player struct is composed of User struct,
methods on User struct are also available to the Player struct
--------------------------------------------------------------

Ex:

/* composition-method.go */
package main

import "fmt"

type User struct {
    Id int
    Name, Location string
}

/* method on pointer to User that returns a string */
func (u *User) Greetings() string {
    return fmt.Sprintf("Hi %s from %s", u.Name, u.Location)
}

type Player struct {
    User
    GameId int
}

func main() {
    /* Initialising with dot notation */
    p1 := Player{}
    p1.Id = 42
    p1.Name = "Sai"
    p1.Location = "KA"
    p1.GameId = 90404

    /* Initialising with struct literal */
    p2 := Player{ User{Id: 42, Name: "Sujai", Location: "TVM"}, 90404,}

    fmt.Println(p1.Greetings())
    fmt.Println(p2.Greetings())
}

$ go run 
Hi Sai from KA
Hi Sujai from TVM

Composition is a very powerful way to build data structures
Its even more interesting when we think about it in the context of interfaces

-------------------------------------------------------------------------------
By composing our structure with a structure that implements a given interface,
our structure automatically implements the interface
-------------------------------------------------------------------------------

In the below example we will look at implementing a Job struct
that can also behave as a logger

package main

import (
    "log"
    "os"
)

type Job struct {
    Command string
    Logger *log.Logger
}

func main() {
    job := &Job{"demo", log.New(os.Stderr, "Job: ", log.Ldate)}
    job.Logger.Print("Test Message")
}

$ go run
Job: 2015/5/7 Test Message

Here the Job struct has a field Logger which is a pointer to another type log.Logger
We set the value of Logger during initialization,
so we are able to call its Print function by chaining calls

   job.Logger.Print()

Go lets us to go even further and use implicit composition

If we skip defining the field for our logger,
then all methods available on a pointer to log.Logger are available from our struct

Ex:

/* implicit-composition.go */
package main

import "log"
import "os"

type Job struct {
    Command string
    *log.Logger
}

func main() {
    job := &Job{"demo", log.New(os.Stderr, "Job: ", log.Lfate)}
    job.Print("Starting now...")
}

Note that we still need to set the logger
What is really nice with the implicit composition is that it allows us to
cheaply and easily make our struct implement interfaces


NOTE:
-----
It is better to compose the Player with a pointer to User struct,
because in Go arguments are passed by value, and our User struct will have
to be copied which is expensive

Below example uses pointer to User struct for composing

/* composing-pointer.go */
package main

import "fmt"

type User struct {
    Id int
    Name, Location string
}

func (u *User) Greetings() string {
    return fmt.Sprintf("Hi %s from %s\n", u.Name, u.Location)
}

type Player struct {
    *User
    GameId int
}

/*************************************/
/* constructor for the Player struct */
func NewPlayer(id int, name, location string, gameId int) *Player {
    return &Player{
        User: &User{id, name, location},
        GameId: gameId,
    }
}

func main() {
    p := NewPlayer(35, "Sujai", "KA", 9611896909)
    fmt.Println(p.Greetings())
}

**************
IMPORTANT NOTE
Methods defined on a pointer are also automatically available on the value itself


